import pandas as pd
import oracledb
import streamlit as st
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import numpy as np
import traceback
import sys

# ConfiguraÃ§Ã£o da pÃ¡gina do Streamlit
st.set_page_config(
    page_title="Painel de Ordens de ServiÃ§o",
    page_icon="ðŸ”§",
    layout="wide"
)

# ConfiguraÃ§Ã£o do Banco de Dados Oracle
# ATENÃ‡ÃƒO: Substitua os valores abaixo com as suas credenciais reais e informaÃ§Ãµes do banco
USERNAME = 'TASY'
PASSWORD = 'aloisk'
HOST = '10.250.250.190'
PORT = 1521
SERVICE = 'dbprod.santacasapc'

# Inicializa o cliente Oracle Instant Client
# Em ambientes Linux/macOS com o Instant Client configurado corretamente,
# oracledb geralmente encontra as bibliotecas sem a necessidade de um path explÃ­cito.
try:
    oracledb.init_oracle_client()
except Exception as e:
    st.sidebar.error(f"Erro na inicializaÃ§Ã£o do Oracle Instant Client: {e}")
    st.sidebar.info("Certifique-se de que o Oracle Instant Client estÃ¡ instalado e configurado corretamente no seu sistema.")

# FunÃ§Ã£o para conectar ao banco de dados Oracle
# Usando st.cache com allow_output_mutation=True para compatibilidade com versÃµes antigas do Streamlit
@st.cache(allow_output_mutation=True, suppress_st_warning=True)
def conectar_ao_banco():
    """Estabelece uma conexÃ£o direta com o banco de dados Oracle usando oracledb."""
    try:
        # Tentativa 1: Usando DSN com formato padrÃ£o
        conn = oracledb.connect(user=USERNAME, password=PASSWORD, 
                               dsn=f"{HOST}:{PORT}/{SERVICE}")
        return conn
    except Exception as e:
        try:
            # Tentativa 2: Usando formato de conexÃ£o EZ
            dsn = f"(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST={HOST})(PORT={PORT}))(CONNECT_DATA=(SERVICE_NAME={SERVICE})))"
            conn = oracledb.connect(user=USERNAME, password=PASSWORD, dsn=dsn)
            return conn
        except Exception as e2:
            st.error(f"Erro ao conectar ao banco de dados: {e2}")
            st.error("Verifique as credenciais, o endereÃ§o do servidor e se o serviÃ§o do banco de dados estÃ¡ ativo.")
            return None

# FunÃ§Ã£o para obter dados das ordens de serviÃ§o
# Adicionamos hash_funcs para lidar com o objeto oracledb.Connection que nÃ£o Ã© hashable
@st.cache(allow_output_mutation=True, suppress_st_warning=True, hash_funcs={oracledb.Connection: lambda _: None})
def obter_ordens_servico(conn):
    """ObtÃ©m os dados das ordens de serviÃ§o do grupo de trabalho 12."""
    if conn is None:
        return pd.DataFrame() # Retorna DataFrame vazio se a conexÃ£o for nula
    try:
        query = """
        select  nr_sequencia as nr_os, 
                ds_dano_breve as ds_solicitacao, 
                obter_nome_pf(cd_pessoa_solicitante) as nm_solicitante, 
                ie_prioridade,
                dt_ordem_servico as dt_criacao, 
                dt_inicio_real as dt_inicio, 
                dt_fim_real as dt_termino, 
                nm_usuario as nm_responsavel, 
                dt_atualizacao as dt_ultima_atualizacao, 
                ds_dano as ds_completa_servico
        from    MAN_ORDEM_SERVICO 
        where   NR_GRUPO_TRABALHO = 12
        """
        
        # Usar pandas para ler diretamente da conexÃ£o
        df = pd.read_sql(query, conn)
        return df
    except Exception as e:
        st.error(f"Erro ao executar consulta: {e}")
        st.error("Verifique a query SQL ou se o banco de dados estÃ¡ acessÃ­vel e a tabela MAN_ORDEM_SERVICO existe.")
        return pd.DataFrame()

# FunÃ§Ã£o para processar e enriquecer os dados
def processar_dados(df):
    """Processa os dados para anÃ¡lise e visualizaÃ§Ã£o."""
    if df.empty:
        return df # Retorna o DataFrame vazio se nÃ£o houver dados para processar

    # Converter todos os nomes de colunas para minÃºsculas para padronizaÃ§Ã£o
    df.columns = [col.lower() for col in df.columns]
    
    # Converter colunas de data para datetime, lidando com erros (coerce)
    colunas_data = ['dt_criacao', 'dt_inicio', 'dt_termino', 'dt_ultima_atualizacao']
    for col in colunas_data:
        if col in df.columns:
            df[col] = pd.to_datetime(df[col], errors='coerce')
    
    # Criar coluna de status
    # Inicializa todas como 'Em aberto'
    df['status'] = 'Em aberto'
    # Se dt_inicio nÃ£o for nulo, status Ã© 'Em andamento'
    df.loc[df['dt_inicio'].notna(), 'status'] = 'Em andamento'
    # Se dt_termino nÃ£o for nulo, status Ã© 'ConcluÃ­da'
    df.loc[df['dt_termino'].notna(), 'status'] = 'ConcluÃ­da'
    
    # Calcular tempo de atendimento (em dias) para OS ConcluÃ­das
    df['tempo_atendimento'] = np.nan # Inicializa com NaN
    mask_atendimento = (df['dt_termino'].notna()) & (df['dt_criacao'].notna())
    df.loc[mask_atendimento, 'tempo_atendimento'] = \
        (df.loc[mask_atendimento, 'dt_termino'] - df.loc[mask_atendimento, 'dt_criacao']).dt.total_seconds() / (24*60*60)
    
    # Calcular tempo de espera para inÃ­cio (em dias) para OS Iniciadas
    df['tempo_espera'] = np.nan # Inicializa com NaN
    mask_espera = (df['dt_inicio'].notna()) & (df['dt_criacao'].notna())
    df.loc[mask_espera, 'tempo_espera'] = \
        (df.loc[mask_espera, 'dt_inicio'] - df.loc[mask_espera, 'dt_criacao']).dt.total_seconds() / (24*60*60)
    
    return df

# FunÃ§Ã£o principal do aplicativo Streamlit
def main():
    # TÃ­tulo do aplicativo na pÃ¡gina
    st.title("ðŸ”§ Painel de Acompanhamento de Ordens de ServiÃ§o")
    
    # Conectar ao banco de dados
    with st.spinner("Conectando ao banco de dados..."):
        conn = conectar_ao_banco()
        
    if conn is None:
        st.error("NÃ£o foi possÃ­vel estabelecer conexÃ£o com o banco de dados. O painel nÃ£o poderÃ¡ exibir dados.")
        return # Interrompe a execuÃ§Ã£o se a conexÃ£o falhar
    
    # Obter dados das Ordens de ServiÃ§o
    with st.spinner("Carregando dados das ordens de serviÃ§o..."):
        df_os = obter_ordens_servico(conn)
        
    if df_os.empty:
        st.warning("NÃ£o foram encontradas ordens de serviÃ§o para o grupo de trabalho 12 ou houve um erro na consulta.")
        st.info("Verifique se o grupo de trabalho '12' possui dados ou se a query SQL estÃ¡ correta.")
        return # Interrompe a execuÃ§Ã£o se nÃ£o houver dados

    # Processar dados obtidos
    df_os = processar_dados(df_os)
    
    # Sidebar para filtros do usuÃ¡rio
    st.sidebar.header("Filtros")
    
    # Filtro de perÃ­odo por data de criaÃ§Ã£o
    st.sidebar.subheader("PerÃ­odo de CriaÃ§Ã£o da OS")
    # Define as datas mÃ­nima e mÃ¡xima disponÃ­veis nos dados ou um perÃ­odo padrÃ£o
    min_date_available = df_os['dt_criacao'].min().date() if not df_os['dt_criacao'].isna().all() else datetime.now().date() - timedelta(days=90)
    max_date_available = df_os['dt_criacao'].max().date() if not df_os['dt_criacao'].isna().all() else datetime.now().date()
    
    # Garante que as datas de input nÃ£o excedam as datas disponÃ­veis ou sejam invertidas
    data_inicio_input = st.sidebar.date_input("Data Inicial", min_date_available, 
                                               min_value=min_date_available, max_value=max_date_available)
    data_fim_input = st.sidebar.date_input("Data Final", max_date_available, 
                                            min_value=min_date_available, max_value=max_date_available)
    
    # Ajuste: Garantir que data_fim_input nÃ£o seja menor que data_inicio_input
    if data_inicio_input > data_fim_input:
        st.sidebar.error("A Data Inicial nÃ£o pode ser maior que a Data Final.")
        df_filtrado = pd.DataFrame() # Esvazia o DataFrame para indicar erro ou dados inconsistentes
    else:
        # Aplica o filtro de data antes dos outros filtros para performance
        df_filtrado = df_os[(df_os['dt_criacao'].dt.date >= data_inicio_input) & 
                                (df_os['dt_criacao'].dt.date <= data_fim_input)].copy()
    
    if df_filtrado.empty:
        st.warning("NÃ£o hÃ¡ dados para o perÃ­odo de criaÃ§Ã£o selecionado. Ajuste o filtro de datas.")
        return # Interrompe a execuÃ§Ã£o se nÃ£o houver dados no perÃ­odo
        
    # Filtro de status
    status_options = ['Todos'] + sorted(df_filtrado['status'].unique().tolist())
    status_selecionado = st.sidebar.selectbox("Status", status_options)
    
    # Filtro de prioridade
    prioridade_options = ['Todas'] + sorted(df_filtrado['ie_prioridade'].unique().tolist())
    prioridade_selecionada = st.sidebar.selectbox("Prioridade", prioridade_options)
    
    # Aplica os filtros de status e prioridade
    if status_selecionado != 'Todos':
        df_filtrado = df_filtrado[df_filtrado['status'] == status_selecionado]
    
    if prioridade_selecionada != 'Todas':
        df_filtrado = df_filtrado[df_filtrado['ie_prioridade'] == prioridade_selecionada]
    
    if df_filtrado.empty:
        st.warning("Nenhuma Ordem de ServiÃ§o encontrada com os filtros aplicados. Tente ajustar os filtros.")
        return # Interrompe a execuÃ§Ã£o se nÃ£o houver dados apÃ³s os filtros
    
    # Exibir mÃ©tricas principais (cards de resumo)
    st.header("Resumo Geral das Ordens de ServiÃ§o Filtradas")
    col1, col2, col3, col4 = st.columns(4) # Cria 4 colunas para os cards
    
    with col1:
        st.metric("Total de OS", len(df_filtrado))
    
    with col2:
        concluidas = len(df_filtrado[df_filtrado['status'] == 'ConcluÃ­da'])
        st.metric("ConcluÃ­das", concluidas)
    
    with col3:
        em_andamento = len(df_filtrado[df_filtrado['status'] == 'Em andamento'])
        st.metric("Em andamento", em_andamento)
    
    with col4:
        em_aberto = len(df_filtrado[df_filtrado['status'] == 'Em aberto'])
        st.metric("Em aberto", em_aberto)
    
    st.markdown("---") # Separador visual

    # SeÃ§Ã£o de AnÃ¡lise - NavegaÃ§Ã£o por abas (usando st.radio para compatibilidade)
    st.header("AnÃ¡lise Detalhada das Ordens de ServiÃ§o")
    tab_selecionada = st.radio(
        "Selecione uma visualizaÃ§Ã£o:",
        ["Status e Prioridade", "Tempo de Atendimento", "Solicitantes", "OS sem ResponsÃ¡vel e Carga de Trabalho"],
        horizontal=True # Deixa as opÃ§Ãµes do radio buttons na horizontal
    )
    
    st.subheader(f"VisualizaÃ§Ã£o: {tab_selecionada}")
    
    if tab_selecionada == "Status e Prioridade":
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("#### DistribuiÃ§Ã£o de OS por Status")
            # GrÃ¡fico de pizza de status
            status_counts = df_filtrado['status'].value_counts().reset_index()
            status_counts.columns = ['Status', 'Quantidade']
            
            fig = px.pie(
                status_counts, 
                values='Quantidade', 
                names='Status',
                title='DistribuiÃ§Ã£o por Status',
                color='Status',
                color_discrete_map={
                    'ConcluÃ­da': '#00CC96',     # Verde
                    'Em andamento': '#FFA15A',  # Laranja
                    'Em aberto': '#EF553B'      # Vermelho
                }
            )
            fig.update_traces(textposition='inside', textinfo='percent+label', 
                              marker=dict(line=dict(color='#000000', width=1))) # Borda para fatias
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            st.write("#### Quantidade de OS por Prioridade e Status")
            # GrÃ¡fico de barras por prioridade e status
            prioridade_counts = df_filtrado.groupby(['ie_prioridade', 'status']).size().reset_index(name='Quantidade')
            
            fig = px.bar(
                prioridade_counts,
                x='ie_prioridade',
                y='Quantidade',
                color='status',
                barmode='group', # Barras agrupadas por prioridade
                title='DistribuiÃ§Ã£o por Prioridade e Status',
                labels={'ie_prioridade': 'Prioridade', 'Quantidade': 'Quantidade de OS'},
                color_discrete_map={
                    'ConcluÃ­da': '#00CC96',
                    'Em andamento': '#FFA15A',
                    'Em aberto': '#EF553B'
                }
            )
            fig.update_layout(xaxis_title="Prioridade", yaxis_title="Quantidade de OS")
            st.plotly_chart(fig, use_container_width=True)
    
    elif tab_selecionada == "Tempo de Atendimento":
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("#### Tempo MÃ©dio de Atendimento por Prioridade")
            # GrÃ¡fico de tempo mÃ©dio de atendimento por prioridade
            # Filtra apenas OS ConcluÃ­das para calcular tempo de atendimento
            df_concluidas = df_filtrado[df_filtrado['status'] == 'ConcluÃ­da']
            tempo_medio = df_concluidas.groupby('ie_prioridade')['tempo_atendimento'].mean().reset_index()
            tempo_medio = tempo_medio.sort_values('tempo_atendimento', ascending=False) # Da maior mÃ©dia para a menor
            
            if not tempo_medio.empty:
                fig = px.bar(
                    tempo_medio,
                    x='ie_prioridade',
                    y='tempo_atendimento',
                    title='Tempo MÃ©dio de Atendimento por Prioridade (dias)',
                    labels={'ie_prioridade': 'Prioridade', 'tempo_atendimento': 'Tempo (dias)'},
                    color='tempo_atendimento',
                    color_continuous_scale=px.colors.sequential.Viridis # Escala de cores contÃ­nua
                )
                fig.update_layout(xaxis_title="Prioridade", yaxis_title="Tempo MÃ©dio (dias)")
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.info("NÃ£o hÃ¡ Ordens de ServiÃ§o ConcluÃ­das no perÃ­odo selecionado para calcular o tempo mÃ©dio de atendimento.")
        
        with col2:
            st.write("#### Tempo MÃ©dio de Espera para InÃ­cio por Prioridade")
            # GrÃ¡fico de tempo mÃ©dio de espera por prioridade
            # Filtra apenas OS que jÃ¡ iniciaram para calcular tempo de espera
            df_iniciadas = df_filtrado[df_filtrado['status'].isin(['Em andamento', 'ConcluÃ­da'])]
            tempo_espera = df_iniciadas.groupby('ie_prioridade')['tempo_espera'].mean().reset_index()
            tempo_espera = tempo_espera.sort_values('tempo_espera', ascending=False) # Da maior mÃ©dia para a menor
            
            if not tempo_espera.empty:
                fig = px.bar(
                    tempo_espera,
                    x='ie_prioridade',
                    y='tempo_espera',
                    title='Tempo MÃ©dio de Espera por Prioridade (dias)',
                    labels={'ie_prioridade': 'Prioridade', 'tempo_espera': 'Tempo (dias)'},
                    color='tempo_espera',
                    color_continuous_scale=px.colors.sequential.Viridis
                )
                fig.update_layout(xaxis_title="Prioridade", yaxis_title="Tempo MÃ©dio (dias)")
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.info("NÃ£o hÃ¡ Ordens de ServiÃ§o que iniciaram no perÃ­odo selecionado para calcular o tempo mÃ©dio de espera.")
    
    elif tab_selecionada == "Solicitantes":
        st.write("#### Top 10 Solicitantes com Mais Ordens de ServiÃ§o")
        # Top 10 solicitantes
        top_solicitantes = df_filtrado['nm_solicitante'].value_counts().reset_index()
        top_solicitantes.columns = ['Solicitante', 'Quantidade']
        top_solicitantes = top_solicitantes.head(10) # Limita aos 10 primeiros
        
        if not top_solicitantes.empty:
            fig = px.bar(
                top_solicitantes,
                x='Quantidade',
                y='Solicitante',
                title='Top 10 Solicitantes',
                orientation='h', # Barras horizontais
                color='Quantidade',
                color_continuous_scale=px.colors.sequential.Viridis
            )
            fig.update_layout(yaxis={'categoryorder':'total ascending'}) # Ordena os solicitantes do menor para o maior na barra
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("NÃ£o hÃ¡ solicitantes com Ordens de ServiÃ§o no perÃ­odo selecionado.")

    # --- NOVA ABA: OS sem ResponsÃ¡vel e Carga de Trabalho ---
    elif tab_selecionada == "OS sem ResponsÃ¡vel e Carga de Trabalho":
        st.subheader("Ordens de ServiÃ§o em Aberto sem ResponsÃ¡vel Designado")
        st.write(
            "Esta seÃ§Ã£o lista as Ordens de ServiÃ§o que estÃ£o atualmente 'Em aberto' e para as quais nenhum responsÃ¡vel foi atribuÃ­do. "
            "Elas sÃ£o ordenadas da mais antiga para a mais recente, ajudando a identificar itens que podem estar parados."
        )
        
        # 1. Lista de OS em Aberto sem ResponsÃ¡vel (Ordenada da mais antiga para a mais nova)
        os_sem_responsavel = df_filtrado[
            (df_filtrado["status"] == "Em aberto") & 
            (df_filtrado["nm_responsavel"].isna()) # Verifica se o responsÃ¡vel Ã© NaN (nulo)
        ].copy() 

        # Ordena pela data de criaÃ§Ã£o, da mais antiga para a mais nova
        os_sem_responsavel = os_sem_responsavel.sort_values(by="dt_criacao", ascending=True)

        if not os_sem_responsavel.empty:
            st.success(f"Foram encontradas **{len(os_sem_responsavel)}** Ordens de ServiÃ§o em aberto sem responsÃ¡vel designada.")
            # Seleciona e renomeia colunas para melhor visualizaÃ§Ã£o na tabela
            st.dataframe(os_sem_responsavel[[
                'nr_os', 'ds_solicitacao', 'dt_criacao', 'ie_prioridade', 'status'
            ]].rename(columns={
                'nr_os': 'NÂº OS', 
                'ds_solicitacao': 'SolicitaÃ§Ã£o', 
                'dt_criacao': 'Data CriaÃ§Ã£o', 
                'ie_prioridade': 'Prioridade', 
                'status': 'Status'
            })) # use_container_width removido para compatibilidade
        else:
            st.info("ðŸŽ‰ Nenhuma Ordem de ServiÃ§o em aberto sem responsÃ¡vel designada no perÃ­odo selecionado! Isso Ã© um Ã³timo sinal de organizaÃ§Ã£o!")
            
        st.markdown("---") # Separador visual para a prÃ³xima seÃ§Ã£o
        
        # 2. Carga de Trabalho por ResponsÃ¡vel
        st.subheader("Carga de Trabalho de Ordens de ServiÃ§o por ResponsÃ¡vel")
        st.write("Aqui vocÃª pode visualizar a quantidade de Ordens de ServiÃ§o designadas a cada tÃ©cnico, separadas entre as que jÃ¡ foram iniciadas ('em andamento') "
                 "e as que ainda aguardam execuÃ§Ã£o ('designadas, nÃ£o iniciadas'). Esse painel auxilia na gestÃ£o da carga de trabalho.")

        # Filtra as OS com um responsÃ¡vel (nÃ£o nulo)
        os_com_responsavel = df_filtrado[df_filtrado["nm_responsavel"].notna()].copy()
        
        if not os_com_responsavel.empty:
            # 2.1 Contagem de OS em andamento (dt_inicio nÃ£o nulo)
            os_em_andamento_real = os_com_responsavel[os_com_responsavel["dt_inicio"].notna()]
            andamento_por_responsavel = (
                os_em_andamento_real["nm_responsavel"].value_counts().reset_index()
            )
            andamento_por_responsavel.columns = ["ResponsÃ¡vel", "Em Andamento"]

            # 2.2 Contagem de OS em aberto designadas (dt_inicio nulo)
            os_em_aberto_designadas = os_com_responsavel[os_com_responsavel["dt_inicio"].isna()]
            aberto_por_responsavel = (
                os_em_aberto_designadas["nm_responsavel"].value_counts().reset_index()
            )
            aberto_por_responsavel.columns = ["ResponsÃ¡vel", "Designadas (nÃ£o iniciadas)"]

            # Junta as informaÃ§Ãµes em um Ãºnico DataFrame
            carga_por_responsavel = pd.merge(
                andamento_por_responsavel,
                aberto_por_responsavel,
                on="ResponsÃ¡vel",
                how="outer",
            ).fillna(0)
            carga_por_responsavel["Em Andamento"] = carga_por_responsavel["Em Andamento"].astype(int)
            carga_por_responsavel["Designadas (nÃ£o iniciadas)"] = carga_por_responsavel["Designadas (nÃ£o iniciadas)"].astype(int)

            # Exibir os tÃ©cnicos com cartÃµes
            num_responsaveis = len(carga_por_responsavel)
            # Garante pelo menos 1 coluna para evitar erro se nÃ£o houver responsÃ¡veis
            num_colunas = min(3, num_responsaveis if num_responsaveis > 0 else 1) 
            colunas = st.columns(num_colunas)

            for idx, row in carga_por_responsavel.iterrows():
                with colunas[idx % num_colunas]: # Distribui os cartÃµes entre as colunas
                    st.info(
                        f"**{row['ResponsÃ¡vel']}**\n\n"
                        f"OS em Andamento: **{row['Em Andamento']}**\n"
                        f"OS Designadas (nÃ£o iniciadas): **{row['Designadas (nÃ£o iniciadas)']}**"
                    )
        else:
            st.info("Nenhuma Ordem de ServiÃ§o no perÃ­odo selecionado foi atribuÃ­da a um responsÃ¡vel.")
    # --- FIM DA NOVA ABA ---
    
    st.markdown("---") # Separador visual

    # Linha do tempo das OS criadas
    st.header("EvoluÃ§Ã£o Mensal das Ordens de ServiÃ§o por Status")
    st.write("Este grÃ¡fico mostra como o nÃºmero de Ordens de ServiÃ§o em diferentes status (ConcluÃ­das, Em Andamento, Em Aberto) evoluiu ao longo do tempo, com base na data de criaÃ§Ã£o.")
    
    # Criar dataframe para linha do tempo
    df_timeline = df_filtrado.copy()
    # Cria uma coluna 'mes_ano' no formato 'AAAA-MM' para agrupamento e ordenaÃ§Ã£o
    df_timeline['mes_ano'] = df_timeline['dt_criacao'].dt.strftime('%Y-%m')
    timeline_data = df_timeline.groupby(['mes_ano', 'status']).size().reset_index(name='quantidade')
    
    # Ordenar por mÃªs-ano para garantir a sequÃªncia correta no grÃ¡fico
    timeline_data['mes_ano_dt'] = pd.to_datetime(timeline_data['mes_ano'] + '-01')
    timeline_data = timeline_data.sort_values('mes_ano_dt')
    
    if not timeline_data.empty:
        fig = px.line(
            timeline_data,
            x='mes_ano',
            y='quantidade',
            color='status',
            title='EvoluÃ§Ã£o de OS por MÃªs',
            labels={'mes_ano': 'MÃªs/Ano', 'quantidade': 'Quantidade de OS'},
            markers=True, # Adiciona marcadores nos pontos de dados
            color_discrete_map={
                'ConcluÃ­da': '#00CC96',
                'Em andamento': '#FFA15A',
                'Em aberto': '#EF553B'
            }
        )
        fig.update_layout(xaxis_title="MÃªs/Ano", yaxis_title="Quantidade de OS")
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.info("NÃ£o hÃ¡ dados de linha do tempo para exibir com os filtros atuais.")
    
    st.markdown("---") # Separador visual

    # Tabela de detalhamento das Ordens de ServiÃ§o
    st.header("Detalhamento das Ordens de ServiÃ§o Filtradas")
    st.write("Visualize todas as Ordens de ServiÃ§o que correspondem aos filtros selecionados, com informaÃ§Ãµes detalhadas para cada uma.")
    
    # Selecionar colunas para exibiÃ§Ã£o na tabela principal
    colunas_exibir = ['nr_os', 'ds_solicitacao', 'nm_solicitante', 'ie_prioridade', 
                      'dt_criacao', 'dt_inicio', 'dt_termino', 'nm_responsavel', 'status']
    
    # Verifica quais colunas da lista existem no DataFrame filtrado
    colunas_existentes = [col for col in colunas_exibir if col in df_filtrado.columns]
    
    # Cria uma cÃ³pia do DataFrame com apenas as colunas existentes para exibiÃ§Ã£o
    df_exibir = df_filtrado[colunas_existentes].copy()
    
    # DicionÃ¡rio para renomear colunas para apresentaÃ§Ã£o amigÃ¡vel
    colunas_renomeadas = {
        'nr_os': 'NÂº OS',
        'ds_solicitacao': 'SolicitaÃ§Ã£o',
        'nm_solicitante': 'Solicitante',
        'ie_prioridade': 'Prioridade',
        'dt_criacao': 'Data CriaÃ§Ã£o',
        'dt_inicio': 'Data InÃ­cio',
        'dt_termino': 'Data TÃ©rmino',
        'nm_responsavel': 'ResponsÃ¡vel',
        'status': 'Status'
    }
    
    # Aplica o renomeamento apenas para as colunas que existem no df_exibir
    renomeacao = {k: v for k, v in colunas_renomeadas.items() if k in df_exibir.columns}
    df_exibir = df_exibir.rename(columns=renomeacao)
    
    # FormataÃ§Ã£o de colunas de data para exibiÃ§Ã£o mais legÃ­vel
    for col in ['Data CriaÃ§Ã£o', 'Data InÃ­cio', 'Data TÃ©rmino']:
        if col in df_exibir.columns and df_exibir[col].dtype.kind == 'M':  # Verifica se Ã© uma coluna datetime
            df_exibir[col] = df_exibir[col].dt.strftime('%d/%m/%Y %H:%M').fillna('N/A')
    
    # Exibir tabela interativa
    st.dataframe(df_exibir) # use_container_width removido para compatibilidade
    
    st.markdown("---") # Separador visual

    # Detalhes de uma Ordem de ServiÃ§o selecionada
    st.header("Detalhes da Ordem de ServiÃ§o Selecionada")
    st.write("Selecione uma Ordem de ServiÃ§o para ver todos os detalhes, incluindo descriÃ§Ãµes completas e tempos calculados.")
    
    # Verifica se a coluna 'nr_os' existe no DataFrame filtrado para a seleÃ§Ã£o
    if 'nr_os' in df_filtrado.columns and not df_filtrado['nr_os'].empty:
        # Cria um selectbox para o usuÃ¡rio escolher uma OS
        os_selecionada_nr = st.selectbox("Selecione o NÃºmero da OS para ver detalhes:", 
                                         sorted(df_filtrado['nr_os'].unique().tolist()))
        
        if os_selecionada_nr:
            # Filtra o DataFrame para obter os detalhes da OS selecionada
            os_detalhes = df_filtrado[df_filtrado['nr_os'] == os_selecionada_nr].iloc[0] # Pega a primeira linha correspondente
            
            col_left, col_right = st.columns(2) # Duas colunas para organizar os detalhes
            
            with col_left:
                st.subheader(f"OS #{os_detalhes['nr_os']}")
                
                # Exibe detalhes bÃ¡sicos, verificando a existÃªncia da coluna e tratando valores nulos
                if 'ds_solicitacao' in os_detalhes and pd.notna(os_detalhes['ds_solicitacao']):
                    st.write(f"**SolicitaÃ§Ã£o:** {os_detalhes['ds_solicitacao']}")
                else: st.write("**SolicitaÃ§Ã£o:** N/A")
                
                if 'nm_solicitante' in os_detalhes and pd.notna(os_detalhes['nm_solicitante']):
                    st.write(f"**Solicitante:** {os_detalhes['nm_solicitante']}")
                else: st.write("**Solicitante:** N/A")
                
                if 'ie_prioridade' in os_detalhes and pd.notna(os_detalhes['ie_prioridade']):
                    st.write(f"**Prioridade:** {os_detalhes['ie_prioridade']}")
                else: st.write("**Prioridade:** N/A")
                
                if 'status' in os_detalhes and pd.notna(os_detalhes['status']):
                    st.write(f"**Status:** {os_detalhes['status']}")
                else: st.write("**Status:** N/A")
                
            with col_right:
                # Exibe datas e responsÃ¡vel, formatando e tratando nulos
                st.write(f"**Data de CriaÃ§Ã£o:** {os_detalhes['dt_criacao'].strftime('%d/%m/%Y %H:%M') if pd.notna(os_detalhes['dt_criacao']) else 'N/A'}")
                st.write(f"**Data de InÃ­cio:** {os_detalhes['dt_inicio'].strftime('%d/%m/%Y %H:%M') if pd.notna(os_detalhes['dt_inicio']) else 'N/A'}")
                st.write(f"**Data de TÃ©rmino:** {os_detalhes['dt_termino'].strftime('%d/%m/%Y %H:%M') if pd.notna(os_detalhes['dt_termino']) else 'N/A'}")
                
                if 'nm_responsavel' in os_detalhes and pd.notna(os_detalhes['nm_responsavel']):
                    st.write(f"**ResponsÃ¡vel:** {os_detalhes['nm_responsavel']}")
                else: st.write("**ResponsÃ¡vel:** N/A")
                
                st.write(f"**Ãšltima AtualizaÃ§Ã£o:** {os_detalhes['dt_ultima_atualizacao'].strftime('%d/%m/%Y %H:%M') if pd.notna(os_detalhes['dt_ultima_atualizacao']) else 'N/A'}")
            
            # DescriÃ§Ã£o completa do serviÃ§o, se disponÃ­vel
            if 'ds_completa_servico' in os_detalhes and pd.notna(os_detalhes['ds_completa_servico']):
                st.subheader("DescriÃ§Ã£o Completa da Ordem de ServiÃ§o")
                st.write(os_detalhes['ds_completa_servico'])
            else:
                st.subheader("DescriÃ§Ã£o Completa da Ordem de ServiÃ§o")
                st.info("Sem descriÃ§Ã£o detalhada disponÃ­vel para esta OS.")
            
            # Calcular e exibir mÃ©tricas de tempo para a OS especÃ­fica
            st.subheader("MÃ©tricas de Tempo da OS")
            
            # Tempo de espera para inÃ­cio
            if pd.notna(os_detalhes['dt_criacao']) and pd.notna(os_detalhes['dt_inicio']):
                tempo_espera = (os_detalhes['dt_inicio'] - os_detalhes['dt_criacao']).total_seconds() / (24*60*60)
                st.write(f"**Tempo de espera para inÃ­cio:** {tempo_espera:.2f} dias")
            else:
                st.write("**Tempo de espera para inÃ­cio:** N/A (OS nÃ£o iniciada ou sem data de criaÃ§Ã£o/inÃ­cio)")
            
            # Tempo total de atendimento
            if pd.notna(os_detalhes['dt_criacao']) and pd.notna(os_detalhes['dt_termino']):
                tempo_total = (os_detalhes['dt_termino'] - os_detalhes['dt_criacao']).total_seconds() / (24*60*60)
                st.write(f"**Tempo total de atendimento:** {tempo_total:.2f} dias")
            else:
                st.write("**Tempo total de atendimento:** N/A (OS nÃ£o concluÃ­da ou sem data de criaÃ§Ã£o/tÃ©rmino)")
    else:
        st.info("Nenhuma Ordem de ServiÃ§o disponÃ­vel para seleÃ§Ã£o ou a coluna 'nr_os' nÃ£o foi encontrada.")

# Ponto de entrada da aplicaÃ§Ã£o Streamlit
if __name__ == "__main__":
    main()
